# Некоторые команды Git:
git add — добавление файлов в индекс.
git status — проверка статуса репозитория. 
git commit — добавление файлов в репозиторий. 
git log — просмотр журнала коммитов. 
git show — просмотр коммита. 
git diff — просмотр изменений до коммита. 
git difftool — запуск внешнего инструмента сравнения файлов. 
git restore — отмена изменений. 
git rm — удаление файлов из индекса. 
git reset — откат коммита. 
git branch — создание новой ветки.
git checkout — переключение между ветками. 
git merge — слияние репозиториев. 
git branch -d — удаление ветки. 
git remote add origin url — привязка локального и удалённого репозитория. 
git remote — просмотр удалённых репозиториев. 
git push — отправка изменений в удалённый репозиторий. тольок после commit
git pull — получение изменений из удалённого репозитория
git help -a - помощь
git clone url - скопировать/клонировать удаленный репозиторий 


### Понятие репозитория
репозиторий - это хранилище кода, включающее: 
1. все файлы и папки проекта
2. историю изменений (commits)
3. информацию о ветках и настройках


### виды репозиториев:
1. Локальный - хранится на компьютере разработчика (папка.git)
2. Удаленный(remote) - либо zethub либо github


### структура проекта 
project/            #корневая папка проекта
|
|
|-- .git/           #скрытая папка с данными git (история, настройки)
|
|-- src/            #исходный код (например, main.py , index.js)
|-- docs/           #документация (readme.md, api-описание)
|-- tests/          #тесты (unit-тесты, интеграционные тесты)
|-- config/         #файлы конфигурации (настройки сервера, БД)
|-- assets/         #ресурсы (изображение, шрифты)
|
|-- .gitignore      #файл, указывающий, какие файлы git должен игнорировать


# основные элементы
- .git/ - служебная папка git (нельзя удалять!)
- README.md - описание проекта (обычно в корне)
- .gitignore - список файлов, которые git не отслеживает


# жизненный цикл файлов в git
файлы в git проходят несколько стадий:
1. неотслеживаемые (untracked) - git о них не знает
2. изменённые (modified) - файлы, которые уже в репозитории, но были изменены.
3. индексированные (staged) - файлы, подготовленные к клммиьу (git add)
4. зафиксированные (commited) - изменения сохранены в репозитории (git comit)


# важные правила
коммиты должны быть атомарными - каждое изменение логически завершённое.
- .gitignore обязателен - чтобы не засорять репозиторий ненужными файлами.
- README.md - лица проекта - должен содержать описание, установку и использование

Открыть поиск-управление учетными данными windows- окно вот такое вот- диспетчер учетных данных виндовс-разворачиваете и нажимаете удалить




# Конспект 18.04

Виды цели и уровни интеграции программных  модулей

Понятие: процесс объединения отдельных компонентов ПО в единую систему, которая обеспечивает им совместное функционирование
Цель интеграции: 
1. Обеспечение взаимодействия модулей
2. Повышение надежности и производительности систем
3. Упрощение разработки и сопровождение ПО
3. Минимизация дублирования функционала
Виды интеграции:
1. По способу взаимодействия: 
1) Горизонтальная интеграция- объединение модулей одного уровня(Например: Взаимодействие между сервисами в микросервисной архитектуре); 2) Вертикальная интеграция- объединение модулей разных уровней, например клиент-серверное взаимодействие
2. По степени связанности:
1) Слабая- модули взаимодействуют через стандартный интерфейсы(API, сообщения, что упрощает замену компонентов(“restfull API”, микросервисы))
2) Сильная- модули тесно зависят друг от друга, изменения одного модуля требуют модификации других(монолитная архитектура)
3. По времени выполнения:
1) Статическая- когда компоненты связываются на этапе компиляции связана с языками программирования 
2) Динамическая- компоненты связываются во время выполнения (у вас открыт сайт происходит подгрузка)
3. По уровню автоматизации: 
1) Ручная- разработчик сам настраивает взаимодействие модулей между собой
2) Автоматизированная интеграция- используется CI-CD и системы сборки


Уровни интеграции:
1. Данных- на этом уровне интеграция осуществляется через общие базы данных, файлы или очереди сообщений(SQL БДs(MySQL, и postgreSQL, блокеры сообщений(rabbitMQ))) 
2. API- сервисный уровень, модули взаимодействуют через API(restGraphQL) примеры: веб –сервисы(flusk) и микросервисная архитектура
3. уровень пользовательского интерфейса UI – интеграция происходит через единый интерфейс (веб, мобильные приложения)
Примеры:
SPA и PVA – реализовать можно через React, Angular, View
Desktop-приложения – можно реализовать через QT
4. Уровень бизнес-логики – интеграция на уровне бизнес-правил и процессов
Примеры:
ERP – системы
Workflow – движки
Инструментальные степени интеграции: 
4.1. Средства сборки и управления зависимостями
- maven, gradle (java).
- npm, yarn (javascript).
- pip (Python).
4.2. CI/CD-инструменты.
- Jenkins, GitLab CI, GitHub Actions – автоматизация сборки и тестирования.
- Docker, Kubernetes – контейнеризация и оркестрация.
4.3. Middleware и брокеры сообщений.
- RabbitMQ, Apache Kafka – асинхронная интеграция.
- Redis – кеширование и Pub/Sub.
4.4. API-шлюзы и сервисные сетки
- Kong, Apigee – управление API.
- Istio, Linkerd – сервис-меш для микросервисов. 
Автоматизация бизнес процессов- использование различных технологий для выполнения повторяющихся задач и повышения эффективности работы организации
Цели автоматизации: 
1. Ускорение выполнения операций
2. Снижение ошибок
3. Оптимизация затрат
4. Повышение управляемости и прозрачности процессов
5. Масштабируемость бизнеса 

Виды бизнеса:
1. Линейные процессы(простые, последовательные без ветвелний)
2. Нелинейные сложные(включают условия, циклы и параллельные потоки)

Виды бизнес-процессов по функциональным областям:
1. Управление документооборотом
2. Финансы и бухгалтерия
3. Логистика и расчеты(Расчет доставки и т.д)
4. HR процесс- рекрутинг и онбординг(погружение в работу компании и задачи)
5. Техподдержка- тикет системы и чат боты для улучшения поддержки функционала

Уровни автоматизации бизнес процессов
1. Базовый уровень- рутинные задачи(оптимизация  и автоматизация простых задач, генерация отчетов, смс рассылка, обработка данных)
2. Средний уровень- work flow автоматизация, применяются brm(business process management)системы- настройка маршрутов согласования различных требований, CRN(1С)
3. Высокий уровень- применяются RPA(robotic process automatization)- роботизированная автоматизация процессов имитация действий пользователя
4. ИИ- анализ данных в чат ботах и прогнозах
4. Инструментальные средства для автоматизации
4.1. Low-code/No-code платформы.
- Zapier – связь между веб-приложениями (Google Docs -> Slack).
- Notion + Automate.io – управление проектами.
4.2. BPM-системы
- Camunda – open-source –решение для моделирования процессов.
- Bizagi – визуальный дизайнер workflow.
- Appian, Pega – корпоративные платформы.
4.3. RPA-инструменты
- UiPath – разработка программного обеспечения.
- utomation Anywhere – облачная автоматизация.
4.4. Интеграционные платформы
- Apache Kafka – потоковая обработка данных.
- MuleSoft – API-интеграция.
5. Этапы внедрения автоматизации
1. Анализ процессов (Выявление узких мест)
2. Выбор инструментов (От бюджета и задач)
3. Прототипирование- тест на правильно выстроенные процессы
4. Внедрение и обучение- адаптация сотрудников к новым процессам, анбординг
5. Оптимизация- сбор метрик и AI




# Пример конфигурации Prettier
{

# Форматировать документ:
    Shift + Alt + F 

# Максимально кол-во символов на одной строке
    "printWidth": 80,
# использовать символы табуляции для отспупов
    "useTabs": true,
# Ширина отступа при табуляции(кол-во пробелов)
    "tabsWidth": 2,
# Использовать точки с запятой в конце выражений JS
    "semi": true,
# Использовать одинарные кавычки или двойные
    "singleQuote": true/false/ничего,
# Правила подстановки завершающей запятой
    1. none - не добавлять финальную запятую 
    2. es5 - добавить запятую там, где это допустимо
    3. all - везде, где синтаксис позволяет
    "trailingComma": "es5", 
# Оставлять ли пустое пространство внутри квадратных или круглых скобках
    "bracketSpacing": true/false,
# Включать ли аргументы функции в круглые скобки
    1. always - всегда
    2. avoid - избегать круглых скобок при одном аргументе
    3. "arrowParens": "always"
# const myFunction = ( name ) => {} (always)
# const myFunction = name => {} (avoid)

# выбор источников и приёмников данных, сопоставление объектов данных 

источник данных - это объект или система, откуда поступают данные для обработки. 
приёмник данных - это объект или система, куда передаются обработанные данные

примеры источников:
1. база данных (sql or nosql)
2. файлы
3. API
4. потоки данные 
примеры приёмников данных:
1. запись результатов
2. отчёты и визуализации 
3. внешние системы
4. облачные хранилища

критерии выбора источников и приёмников
при выборе учитывают:
1. формат данных (структурированный, полуструктурированный и неструктурированный)
2. объём данных (большие данные требуют распределённых систем)
3. частота обновления (realtime, пакетная обработка)
4. надёжность и доступность
5. безопасность (безопасность можно обеспечить с помощью шифрования)
6. стоимость (лицензии, облачные тарифы)

сопоставление объектов данных 
сопоставление объектов данных - процесс преобразования данных между источником и приёмником
этапы сопоставления  :
1. анализ структуры данных 
2. преобразование типов
3. маппинг полей - это сопоставление названий столбцов
4. обработка отсутствующих данных (при отсутствии данных поля заполняются либо дефолтными значениями, либо явно указанными)
5. валидация - это проверка на корректность 

инструменты для маппинга:
проблемы и решения:
1. если схемы не совпадают - проблему решают использование унифицированных форматов
2. если данные теряются - на помощь приходит логирование и мониторинг (графа)
3. для производительности оптимизируются запросы, индексы и реализуется кэширование

# транспортные протоколы, стандарты формирования сообщений

транспортные протоколы определяют правила передачи данных 

основные транспортные протоколы: 
1. http/https
http - это хайпер текст, трансфер-протокол
это протокол для передачи данных в веб-среде (незащищённых)
https - http(secure) - защищённая версия с шифрованием (SSL/TLS)

метод: GET, POST, PUT, DELETE и другие.
использование:REST API, веб-приложения.

2. WebSocket
    - двусторонни протокол для обмена сообщениями в реальном времени
    - преимущества: низкие задержки, постоянное соединение
    - использование: онлайн-читы, чаты, биржевые кортировки
3. TCP/IP и UDP
    - TCP - надёжная передача с подтверждением (гарантирует доставку)
    используется в HTTP, FTP, SMTP

- UDP - быстрая передача без гарантии доставки.
используется в VoIP, стриминге, DNS

4. MQTT
    - легковесный протокол для IoT и устройств с ограниченными ресурсами
    - работает по модели издатель-подписчик (Pub/Sub)
5. AMQP
    - протокол для асинхронного обмена сообщениями между системами
    - поддержка очередей (rabbitmq, apache kafka)
6. gRPC
    - высокопроизводительный RPC-протокол на основе HTTP/2
    - использует бинарный формат (protocol buggers).
# Стандарты формирования сообщений
форматы сообщений определяют структуру данных для обмена между системами

текстовые форматы:
1. json (javascript object notation) - легковесный, легко читаемый, структура (ключ-значение) и формат ({ "name": "John, "age": 30})
используется в rest-API
2. XML - это структурированный формат с поддержкой схем xsd
пример: 
<user>
    <name>John</name>
    <age>30</age>
</user>

3. YML - упрощённый синтаксис, 
пример:

user:
    name: John
    age: 30


# выбор протокола и формата
для web-API, как правило, используется http/https + JSON
для социальных сетей - веб-сокет + messagepack

#



